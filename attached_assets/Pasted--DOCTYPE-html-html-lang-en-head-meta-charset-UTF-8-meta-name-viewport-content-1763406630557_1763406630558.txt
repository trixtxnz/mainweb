<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Retro Platformer - Randomized</title>
    <style>
        /* Custom retro/pixel font */
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            background-color: #0d1b2a; /* Dark blue background */
            font-family: 'Press Start 2P', cursive;
            color: #e0fbfc; /* Light cyan text */
            padding: 10px;
        }

        #game-container {
            border: 5px solid #ffc300; /* Gold border */
            box-shadow: 0 0 20px rgba(255, 195, 0, 0.7); /* Glow effect */
            background-color: #2b3a55; /* Slightly lighter game background */
            border-radius: 10px;
            overflow: hidden;
        }

        canvas {
            display: block;
        }

        .game-info {
            width: 100%;
            max-width: 900px; /* Adjusted for new width */
            text-align: center;
            margin-bottom: 10px;
            font-size: 0.8rem;
        }
        
        .temp-settings {
            margin-top: 5px;
            font-size: 0.65rem;
            color: #ff8c00; 
            line-height: 1.2;
        }

        .mega-settings {
            margin-top: 5px;
            font-size: 0.65rem;
            color: #ff0000;
            line-height: 1.2;
        }

        .controls {
            margin-top: 20px;
            text-align: center;
            font-size: 0.8rem;
            line-height: 1.5;
            color: #ade8f4;
        }

        .controls b {
            color: #ff9800;
        }
    </style>
</head>
<body>

    <div class="game-info">
        <div id="status-message" style="color: #48e42f;">Use controls to reach the gem!</div>
        <div id="temp-proj-settings" class="temp-settings"></div>
        <div id="mega-proj-settings" class="mega-settings"></div>
    </div>

    <div id="game-container">
        <canvas id="gameCanvas"></canvas>
    </div>

    <div class="controls">
        Move: <b>&larr;</b> & <b>&rarr;</b> | Jump: <b>&uarr;</b>/W/Space | Stop Fall: <b>S</b> | Wall Jump Enabled! | Reset: <b>R</b>
    </div>

    <script>
        // --- Setup ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const STATUS_MESSAGE = document.getElementById('status-message');
        const TEMP_PROJ_DISPLAY = document.getElementById('temp-proj-settings');
        const MEGA_PROJ_DISPLAY = document.getElementById('mega-proj-settings'); // New display element

        // NEW DIMENSIONS: Larger game area
        const GAME_WIDTH = 900; 
        const GAME_HEIGHT = 550; 
        const GROUND_HEIGHT = 10; 
        const WALL_THICKNESS = 10; 

        canvas.width = GAME_WIDTH;
        canvas.height = GAME_HEIGHT;

        // Physics Constants
        const GRAVITY = 0.4;
        const PLAYER_MOVE_SPEED = 5;
        const JUMP_VELOCITY = -10;
        const WALL_JUMP_X_VELOCITY = 8; 
        
        // --- PERMANENT TURRET PROJECTILE SETTINGS ---
        const PROJECTILE_SPEED = 8; 
        const PROJECTILE_COLOR = '#ff4500'; 
        const PROJECTILE_RADIUS = 5;
        
        // --- TEMPORARY TURRET SETTINGS (CUSTOMIZABLE) ---
        const TEMP_PROJ_SPEED = 4;    
        const TEMP_PROJ_COLOR = '#ff8c00'; 
        const TEMP_PROJ_RADIUS = 5;    

        const TURRET_LIFESPAN_MS = 2000;
        const TEMPORARY_TURRET_SPAWN_COOLDOWN_MS = 50; 
        const MAX_ACTIVE_TEMPORARY_TURRETS = 6; 
        
        // --- MEGA TURRET/PROJECTILE SETTINGS (NEW) ---
        const MEGA_PROJECTILE_RADIUS = 12; // Bigger ball radius
        const MEGA_PROJECTILE_COLOR = '#ff0000'; // Red color
        const MEGA_PROJECTILE_SPEED = 5;
        const MEGA_TURRET_COOLDOWN = 4000; // Slow firing rate
        
        const MINI_PROJECTILE_COUNT = 8; // Number of smaller projectiles
        const MINI_PROJECTILE_RADIUS = 3; // Tiny projectile size
        const MINI_PROJECTILE_SPEED = 5; // Fast spread speed
        const MINI_PROJECTILE_COLOR = '#ffc300'; // Gold color

        // Safety Zone Constant
        const START_ZONE_CLEARANCE = 150; // Minimum vertical clearance (in pixels) from player's start Y position.

        // Jump Mechanics
        const COYOTE_TIME_MAX = 100; 
        const JUMP_BUFFER_MAX = 100; 

        // Game State
        let gameRunning = false;
        let keys = {};

        // Game Objects Arrays
        let platforms = [];
        let collectible;
        let player;
        let turrets = [];          
        let temporaryTurrets = []; 
        let megaTurrets = []; // New array for mega turrets
        let projectiles = []; 
        let lastTime = 0;

        // Temporary Turret Management
        let temporaryTurretCooldown = TEMPORARY_TURRET_SPAWN_COOLDOWN_MS; 
        
        // --- Game Objects (Classes) ---
        
        class Player {
            // ... (Player class remains unchanged) ...
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.width = 25;
                this.height = 25;
                this.vx = 0; 
                this.vy = 0; 
                this.onGround = true;
                this.onWall = false; 
                this.wallSide = 0;   
                this.color = '#ff9800'; 

                this.coyoteTimeCounter = 0; 
                this.jumpBufferCounter = 0; 
            }

            getBounds() {
                return {
                    left: this.x,
                    right: this.x + this.width,
                    top: this.y,
                    bottom: this.y + this.height
                };
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
            }

            update(deltaTime) {
                if (!gameRunning) return;

                // 1. Manage Counters
                this.jumpBufferCounter = Math.max(0, this.jumpBufferCounter - deltaTime);

                if (this.onGround) {
                    this.coyoteTimeCounter = COYOTE_TIME_MAX;
                } else {
                    this.coyoteTimeCounter = Math.max(0, this.coyoteTimeCounter - deltaTime);
                }

                // 2. Horizontal Movement
                const isWallJumpMomentum = Math.abs(this.vx) > PLAYER_MOVE_SPEED * 1.5; 

                if (isWallJumpMomentum) {
                    this.vx *= 0.9;
                } else {
                    this.vx = 0;
                    if ((keys['ArrowLeft'] || keys['KeyA']) && this.x > 0) {
                        this.vx = -PLAYER_MOVE_SPEED;
                    }
                    if ((keys['ArrowRight'] || keys['KeyD']) && this.x < GAME_WIDTH - this.width) {
                        this.vx = PLAYER_MOVE_SPEED;
                    }
                }

                // 3. Apply Gravity
                if (!this.onGround) {
                    this.vy += GRAVITY;
                }

                this.x += this.vx;
                this.y += this.vy;

                // Reset states *before* collision checks 
                this.onGround = false;
                this.onWall = false; 
                this.wallSide = 0;

                // --- Canvas Edge Boundary Check ---
                const isPlayerMidAir = this.y + this.height < GAME_HEIGHT - GROUND_HEIGHT;

                // Check Left Boundary
                if (this.x < 0) {
                    this.x = 0; 
                    if (isPlayerMidAir) { 
                        this.onWall = true;
                        this.wallSide = -1; 
                    }
                } 

                // Check Right Boundary
                else if (this.x + this.width > GAME_WIDTH) {
                    this.x = GAME_WIDTH - this.width; 
                    if (isPlayerMidAir) { 
                        this.onWall = true;
                        this.wallSide = 1; 
                    }
                }
            }

            jump() {
                if (!gameRunning) return;

                // Ground Jump (using coyote time)
                if (this.onGround || this.coyoteTimeCounter > 0) {
                    this.vy = JUMP_VELOCITY;
                    this.onGround = false;
                    this.coyoteTimeCounter = 0;
                    this.jumpBufferCounter = 0;
                    return;
                }

                // Wall Jump 
                if (this.onWall) {
                    this.vy = JUMP_VELOCITY; 
                    this.vx = -this.wallSide * WALL_JUMP_X_VELOCITY; 
                    this.onWall = false; 
                    this.wallSide = 0;
                    this.jumpBufferCounter = 0; 
                    return;
                }

                // Buffer the input
                this.jumpBufferCounter = JUMP_BUFFER_MAX;
            }
        }

        class Platform {
            // ... (Platform class remains unchanged) ...
            constructor(x, y, w, h) {
                this.x = x;
                this.y = y;
                this.width = w;
                this.height = h;
                this.color = '#48e42f'; 
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);
            }
        }

        class Collectible {
            // ... (Collectible class remains unchanged) ...
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.size = 20;
                this.color = '#00ffff'; 
                this.collected = false;
            }

            draw() {
                if (!this.collected) {
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.moveTo(this.x + this.size / 2, this.y);
                    ctx.lineTo(this.x + this.size, this.y + this.size / 2);
                    ctx.lineTo(this.x + this.size / 2, this.y + this.size);
                    ctx.lineTo(this.x, this.y + this.size / 2);
                    ctx.closePath();
                    ctx.fill();

                    ctx.shadowBlur = 10;
                    ctx.shadowColor = this.color;
                }
            }
        }

        class Projectile {
            constructor(x, y, angle, speed, color, radius, isMega = false) { 
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.color = color; 

                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;

                this.isDead = false;
                this.isMega = isMega; // New property
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;

                if (this.x < 0 || this.x > GAME_WIDTH || this.y < 0 || this.y > GAME_HEIGHT) {
                    this.isDead = true;
                }
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();

                ctx.shadowBlur = 10;
                ctx.shadowColor = this.color;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
            }
        
            // --- NEW FUNCTION: Explosion Logic ---
            explodeIntoMiniProjectiles() {
                const miniProjectiles = [];
                for (let i = 0; i < MINI_PROJECTILE_COUNT; i++) {
                    // Spread the mini projectiles evenly in a circle (0 to 2*PI)
                    const angle = (i / MINI_PROJECTILE_COUNT) * (Math.PI * 2); 
                    miniProjectiles.push(new Projectile(
                        this.x, 
                        this.y, 
                        angle, 
                        MINI_PROJECTILE_SPEED, 
                        MINI_PROJECTILE_COLOR, 
                        MINI_PROJECTILE_RADIUS
                    ));
                }
                return miniProjectiles;
            }
            // -------------------------------------
        }


        class Turret {
            constructor(x, y, angle = 0, minX = x, maxX = x, minY = y, maxY = y, moveSpeed = 0, isTemporary = false, isMegaTurret = false) { 
                this.x = x;
                this.y = y;
                this.angle = angle; 
                this.width = 30;
                this.height = 10;
                this.isTemporary = isTemporary;
                this.isMegaTurret = isMegaTurret; // New property

                if (this.isMegaTurret) {
                    this.color = '#330000'; // Darker red/black for mega turret base
                    this.fireCooldown = MEGA_TURRET_COOLDOWN;
                } else if (this.isTemporary) {
                    this.color = '#ff00ff'; // Magenta for temporary
                    this.fireCooldown = 2000;
                } else {
                    this.color = '#7f0000'; // Dark Red for permanent
                    this.fireCooldown = 2000;
                }
                
                this.isDead = false;

                this.timeUntilNextShot = 0; 
                
                // Use the new TURRET_LIFESPAN_MS constant
                this.despawnTimer = isTemporary ? TURRET_LIFESPAN_MS : Infinity; 
                this.hasFired = false;

                this.minX = minX;
                this.maxX = maxX;
                this.minY = minY; 
                this.maxY = maxY; 
                this.moveSpeed = moveSpeed; 
                this.isMovingX = this.minX !== this.maxX; 
                this.isMovingY = this.minY !== this.maxY; 

                if (this.isMovingX && this.isMovingY) {
                    this.isMovingY = false;
                }

                if (this.isMovingX) {
                    this.directionX = 1; 
                } else if (this.isMovingY) {
                    this.directionY = 1; 
                }
            }

            getMuzzlePosition() {
                const center = { x: this.x + this.width / 2, y: this.y + this.height / 2 };
                // Slightly larger offset for the mega turret visually
                const offset = (this.isMegaTurret ? this.width / 2 + 10 : this.width / 2 + 5); 
                const dx = Math.cos(this.angle);
                const dy = Math.sin(this.angle);

                return {
                    x: center.x + offset * dx,
                    y: center.y + offset * dy
                };
            }

            update(deltaTime, projectiles) {
                // 1. Movement Logic (Patrolling - only for permanent and mega)
                if (!this.isTemporary) {
                    const deltaMovement = (this.moveSpeed * deltaTime) / 1000; 

                    if (this.isMovingX) {
                        this.x += deltaMovement * this.directionX;

                        if (this.directionX === 1 && this.x + this.width >= this.maxX) {
                            this.x = this.maxX - this.width; 
                            this.directionX = -1; 
                        } else if (this.directionX === -1 && this.x <= this.minX) {
                            this.x = this.minX; 
                            this.directionX = 1; 
                        }
                    }

                    if (this.isMovingY) {
                        this.y += deltaMovement * this.directionY;

                        if (this.directionY === 1 && this.y + this.height >= this.maxY) {
                            this.y = this.maxY - this.height; 
                            this.directionY = -1; 
                        } else if (this.directionY === -1 && this.y <= this.minY) {
                            this.y = this.minY; 
                            this.directionY = 1; 
                        }
                    }
                }

                // 2. Firing Logic
                this.timeUntilNextShot -= deltaTime;

                if (this.timeUntilNextShot <= 0) {
                    if (this.isTemporary && this.hasFired) {
                        // Temporary turrets fire once
                    } else {
                        const muzzle = this.getMuzzlePosition();
                        
                        let projSpeed = PROJECTILE_SPEED;
                        let projColor = PROJECTILE_COLOR;
                        let projRadius = PROJECTILE_RADIUS;
                        let isMega = false;

                        // Use custom settings for temporary turrets
                        if (this.isTemporary) {
                            projSpeed = TEMP_PROJ_SPEED;
                            projColor = TEMP_PROJ_COLOR;
                            projRadius = TEMP_PROJ_RADIUS;
                        } 
                        // Use custom settings for Mega turrets
                        else if (this.isMegaTurret) {
                            projSpeed = MEGA_PROJECTILE_SPEED;
                            projColor = MEGA_PROJECTILE_COLOR;
                            projRadius = MEGA_PROJECTILE_RADIUS;
                            isMega = true;
                        }

                        projectiles.push(new Projectile(muzzle.x, muzzle.y, this.angle, projSpeed, projColor, projRadius, isMega));
                        this.hasFired = true;
                        
                        if (!this.isTemporary) {
                            this.timeUntilNextShot = this.fireCooldown; 
                        } else {
                            this.timeUntilNextShot = 9999999; 
                        }
                    }
                }
                
                // 3. Despawn Logic (for temporary turrets)
                if (this.isTemporary) {
                    if (this.hasFired) {
                        this.despawnTimer -= deltaTime;
                        if (this.despawnTimer <= 0) {
                            this.isDead = true;
                        }
                    }
                }
            }

            draw() {
                const cx = this.x + this.width / 2;
                const cy = this.y + this.height / 2;

                ctx.save();
                ctx.translate(cx, cy);
                ctx.rotate(this.angle);
                ctx.translate(-cx, -cy);

                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.width, this.height);

                // Draw the muzzle, different color/size for Mega Turret
                ctx.fillStyle = this.isMegaTurret ? '#ff0000' : (this.isTemporary ? '#ffc300' : '#ff4500'); 
                ctx.beginPath();
                // Draw a bigger, more pronounced muzzle for the mega turret
                const muzzleRadius = this.isMegaTurret ? 6 : 4; 
                ctx.arc(this.x + this.width + 5, this.y + this.height / 2, muzzleRadius, 0, Math.PI * 2);
                ctx.fill();

                ctx.restore(); 
                ctx.shadowBlur = 0; 
            }
        }
        
        // --- Level Data (Modules) ---
        const LevelModules = [
            // Module 1: Two small platforms high and low (NO TURRET) - Updated for higher platform
            {
                moduleWidth: 150, 
                platforms: [
                    [10, GAME_HEIGHT - 60, 50, 15],
                    [80, GAME_HEIGHT - 120, 50, 15],
                    [20, GAME_HEIGHT - 200, 50, 15] // Added higher platform
                ],
                turrets: [],
                megaTurrets: [], // Added for consistency
                spawnPoints: [
                    [25, GAME_HEIGHT - 60 - 25], 
                    [95, GAME_HEIGHT - 120 - 25],
                    [35, GAME_HEIGHT - 200 - 25] // New spawn point
                ]
            },
            // Module 2: Long platform with static downward turret (HAS TURRET)
            {
                moduleWidth: 200,
                platforms: [
                    [20, GAME_HEIGHT - 100, 160, 15]
                ],
                turrets: [
                    [100, GAME_HEIGHT - 170 - 10 - 30, Math.PI / 2]
                ],
                megaTurrets: [],
                spawnPoints: [
                    [50, GAME_HEIGHT - 100 - 25], 
                    [150, GAME_HEIGHT - 100 - 25] 
                ]
            },
            // Module 3: High platform with moving horizontal turret (HAS TURRET)
            {
                moduleWidth: 250,
                platforms: [
                    [50, GAME_HEIGHT - 180, 180, 15]
                ],
                turrets: [
                    [200, GAME_HEIGHT - 180 - 10, Math.PI, 60, 200, 0, 0, 50]
                ],
                megaTurrets: [],
                spawnPoints: [
                    [80, GAME_HEIGHT - 180 - 25], 
                    [180, GAME_HEIGHT - 180 - 25]
                ]
            },
            // Module 4: Tall vertical wall for wall jump practice (NO TURRET)
            {
                moduleWidth: 80,
                platforms: [
                    [30, GAME_HEIGHT - 100, 20, 90], 
                ],
                turrets: [],
                megaTurrets: [],
                spawnPoints: [
                    [50, GAME_HEIGHT - 100 - 25], 
                    [40, GAME_HEIGHT - 200]
                ]
            },
            // Module 5: Steep vertical platforms for upward movement 
            {
                moduleWidth: 150,
                platforms: [
                    [20, GAME_HEIGHT - 150, 40, 10],   // Lower left (y=400)
                    [90, GAME_HEIGHT - 250, 40, 10],   // Middle right (y=300)
                    [20, GAME_HEIGHT - 350, 40, 10]   // Higher left (y=200)
                ],
                turrets: [],
                megaTurrets: [],
                spawnPoints: [
                    [30, GAME_HEIGHT - 150 - 25],
                    [100, GAME_HEIGHT - 250 - 25],
                    [30, GAME_HEIGHT - 350 - 25]
                ]
            },
            // Module 6: High ceiling ledge with right diagonal turret
            {
                moduleWidth: 220,
                platforms: [
                    [20, GAME_HEIGHT - 100, 40, 10], // Base jump pad
                    [70, GAME_HEIGHT - 380, 120, 10] // High ledge (y=170)
                ],
                turrets: [
                    // Turret pointing diagonally down-right from the high ledge (45 degrees)
                    [100, GAME_HEIGHT - 379 - 10, Math.PI / 4, 100, 100, 0, 0, 0]
                ],
                megaTurrets: [],
                spawnPoints: [
                    [30, GAME_HEIGHT - 100 - 25],
                    [120, GAME_HEIGHT - 380 - 25]
                ]
            },
            // Module 7: High ceiling ledge with left diagonal turret
            {
                moduleWidth: 220,
                platforms: [
                    [20, GAME_HEIGHT - 100, 40, 10], // Base jump pad
                    [70, GAME_HEIGHT - 380, 120, 10] // High ledge (y=170)
                ],
                turrets: [
                    // Turret pointing diagonally down-left from the high ledge (45 degrees)
                    [100, GAME_HEIGHT - 379 - 10, Math.PI / 1.5, 100, 100, 0, 0, 0]
                ],
                megaTurrets: [],
                spawnPoints: [
                    [30, GAME_HEIGHT - 100 - 25],
                    [120, GAME_HEIGHT - 380 - 25]
                ]
            },
            // Module 8: middle horizontal platform 
            {
                moduleWidth: 150,
                platforms: [
                    [90, GAME_HEIGHT - 250, 40, 10],   // Middle right (y=300)
                ],
                turrets: [],
                megaTurrets: [],
                spawnPoints: [
                    [30, GAME_HEIGHT - 150 - 25],
                    [100, GAME_HEIGHT - 250 - 25],
                    [30, GAME_HEIGHT - 350 - 25]
                ]
            },
            // --- NEW MEGA TURRET MODULES ---
            // Module 9: Platform with a Mega Turret firing horizontally (Left)
            {
                moduleWidth: 200,
                platforms: [
                    [20, GAME_HEIGHT - 200, 160, 15] // High platform
                ],
                turrets: [],
                megaTurrets: [
                    // Mega Turret firing left (angle Math.PI) from the right side of the platform
                    [160, GAME_HEIGHT - 200 - 10, Math.PI, 0, 0, 0, 0, 0] 
                ],
                spawnPoints: [
                    [50, GAME_HEIGHT - 200 - 25], 
                    [150, GAME_HEIGHT - 200 - 25]
                ]
            },
            // Module 10: Ground-level Mega Turret firing diagonally up-right
            {
                moduleWidth: 250,
                platforms: [],
                turrets: [],
                megaTurrets: [
                    // Mega Turret firing diagonally up-right (angle -Math.PI / 4) from the ground
                    [20, GAME_HEIGHT - GROUND_HEIGHT - 10, -Math.PI / 4, 0, 0, 0, 0, 0] 
                ],
                spawnPoints: [
                    [100, GAME_HEIGHT - 250 - 25],
                ]
            },
        ];


        // Utility function to add a single temporary turret at a non-overlapping spot
        function addSingleTemporaryTurret() {
            const turretWidth = 30;
            const turretHeight = 10;
            const MIN_SPACING = 30; 
            
            // Boundary definitions for spawning
            const INNER_LEFT_BOUND = WALL_THICKNESS;
            const INNER_RIGHT_BOUND = GAME_WIDTH - WALL_THICKNESS;
            
            // Safe vertical range for the turret's top edge (avoids the top wall and the ground)
            const minY_Safe = WALL_THICKNESS + 10;
            const maxY_Safe = GAME_HEIGHT - GROUND_HEIGHT - turretHeight - 10;
            const verticalRange = maxY_Safe - minY_Safe;


            // 1. Choose Wall and Angle (Left or Right only)
            const edgeChoice = Math.random() < 0.5 ? 0 : 1; 
            let x, angle;
            const isLeftWall = (edgeChoice === 0);

            if (isLeftWall) { 
                // Left Edge (Fires Right)
                x = INNER_LEFT_BOUND;
                angle = 0;
            } else { 
                // Right Edge (Fires Left)
                x = INNER_RIGHT_BOUND - turretWidth;
                angle = Math.PI;
            }
            
            // 2. Find a non-overlapping Y position
            let y = null;
            let attempts = 0;
            const MAX_ATTEMPTS = 100; 

            // Calculate the player's initial top Y position (where they start)
            const playerStartTopY = GAME_HEIGHT - player.height - GROUND_HEIGHT - 1; 

            do {
                attempts++;
                // Pick a random Y within the safe range
                const potentialY = Math.random() * verticalRange + minY_Safe;
                
                let isOverlapping = false;
                
                // Check against player starting location if spawning on the left wall
                if (isLeftWall) {
                    // Check if the turret's top edge (potentialY) is too low and near the player's start Y.
                    // If the turret is below the required clearance boundary, it's too close.
                    if (potentialY > playerStartTopY - START_ZONE_CLEARANCE) {
                        isOverlapping = true;
                    }
                }

                // Check against existing temporary turrets
                if (!isOverlapping) {
                    for (const existingTurret of temporaryTurrets) {
                        // Only check for overlap if the existing turret is on the SAME wall
                        if (existingTurret.x === x) { 
                            const newTurretTop = potentialY;
                            const newTurretBottom = potentialY + turretHeight;
                            const existingTurretTop = existingTurret.y;
                            const existingTurretBottom = existingTurret.y + existingTurret.height;
        
                            // Overlap check including MIN_SPACING
                            if (newTurretTop < existingTurretBottom + MIN_SPACING && 
                                newTurretBottom > existingTurretTop - MIN_SPACING) {
                                isOverlapping = true;
                                break;
                            }
                        }
                    }
                }


                if (!isOverlapping) {
                    y = potentialY;
                    break;
                }
            } while (y === null && attempts < MAX_ATTEMPTS);
            
            if (y === null) {
                // Failed to find a spot, return null
                return null; 
            }

            // 3. Create and return the new turret
            return new Turret(
                x, y, angle, 
                x, x, y, y, 0, 
                true 
            );
        }

        // Function to create and add multiple temporary turrets in a burst
        function attemptRefillTemporaryTurrets() {
            // Loop and spawn until we hit the maximum limit
            while (temporaryTurrets.length < MAX_ACTIVE_TEMPORARY_TURRETS) {
                const newTurret = addSingleTemporaryTurret();
                if (newTurret) {
                    temporaryTurrets.push(newTurret);
                } else {
                    // Break the loop if we can't find a non-overlapping position
                    break; 
                }
            }
        }

        // Level Generation Function
        function generateLevel() {
            let currentX = 0; 
            // Increased number of modules to fill the new, wider area and account for new vertical modules
            const numModules = 15; 
            const allSpawnPoints = []; 

            // 1. Initial Platforms (Ground and Walls)
            platforms.push(
                new Platform(0, GAME_HEIGHT - GROUND_HEIGHT, GAME_WIDTH, GROUND_HEIGHT),
                new Platform(0, 0, WALL_THICKNESS, GAME_HEIGHT - GROUND_HEIGHT),
                new Platform(GAME_WIDTH - WALL_THICKNESS, 0, WALL_THICKNESS, GAME_HEIGHT - GROUND_HEIGHT)
            );

            // Set player start position
            player.x = WALL_THICKNESS + 25;
            player.y = GAME_HEIGHT - player.height - GROUND_HEIGHT - 1;
            currentX = player.x + player.width + 50; 
            
            let availableModules = LevelModules; 
            
            // 2. Randomly pick and place modules
            for (let i = 0; i < numModules; i++) {
                // Stop generating if we run out of horizontal space
                if (currentX >= GAME_WIDTH - 150) break; 

                const randomIndex = Math.floor(Math.random() * availableModules.length);
                const module = availableModules[randomIndex];

                // Create platforms
                module.platforms.forEach(pData => {
                    platforms.push(new Platform(pData[0] + currentX, pData[1], pData[2], pData[3]));
                });

                // Create permanent turrets
                module.turrets.forEach(tData => {
                    const [x, y, angle, minX_offset, maxX_offset, minY_offset, maxY_offset, moveSpeed] = tData;
                    
                    const minX = currentX + minX_offset;
                    const maxX = currentX + maxX_offset;
                    const minY = y + minY_offset; 
                    const maxY = y + maxY_offset;
                    
                    turrets.push(new Turret(x + currentX, y, angle, minX, maxX, minY, maxY, moveSpeed, false, false));
                });
                
                // Create MEGA turrets (NEW)
                if (module.megaTurrets) {
                    module.megaTurrets.forEach(tData => {
                        const [x, y, angle, minX_offset, maxX_offset, minY_offset, maxY_offset, moveSpeed] = tData;
                        
                        const minX = currentX + minX_offset;
                        const maxX = currentX + maxX_offset;
                        const minY = y + minY_offset; 
                        const maxY = y + maxY_offset;
                        
                        // Pass true for the isMegaTurret flag
                        megaTurrets.push(new Turret(x + currentX, y, angle, minX, maxX, minY, maxY, moveSpeed, false, true));
                    });
                }
                
                // Save potential collectible spawn points
                module.spawnPoints.forEach(sPoint => {
                    if (sPoint[0] + currentX < GAME_WIDTH - WALL_THICKNESS - 10) {
                        allSpawnPoints.push({
                            x: sPoint[0] + currentX,
                            y: sPoint[1]
                        });
                    }
                });

                currentX += module.moduleWidth + Math.random() * 30 + 20; 
            }

            // 3. Guaranteed Collectible Placement on the furthest valid platform (highest X)
            let furthestSpawnPos = null;
            let maxDistanceX = -1;

            if (allSpawnPoints.length > 0) {
                // Find the spawn point with the maximum X coordinate
                for (const pos of allSpawnPoints) {
                    if (pos.x > maxDistanceX) {
                        maxDistanceX = pos.x;
                        furthestSpawnPos = pos;
                    }
                }
                
                if (furthestSpawnPos) {
                    collectible = new Collectible(furthestSpawnPos.x, furthestSpawnPos.y);
                } else {
                     // Fallback 1
                     collectible = new Collectible(GAME_WIDTH - WALL_THICKNESS - 30, GAME_HEIGHT - GROUND_HEIGHT - 30);
                }
            } else {
                 // Fallback 2
                 collectible = new Collectible(GAME_WIDTH - WALL_THICKNESS - 30, GAME_HEIGHT - GROUND_HEIGHT - 30);
            }
        }

        function initializeGame() {
            gameRunning = true;
            STATUS_MESSAGE.textContent = 'Active...';
            STATUS_MESSAGE.style.color = '#b2ff59';
            keys = {};

            platforms = [];
            turrets = [];
            temporaryTurrets = [];
            megaTurrets = []; // Clear mega turrets
            projectiles = []; 
            // Initialize cooldown to 0 so the first batch spawns instantly on the first frame
            temporaryTurretCooldown = 0;
            
            player = new Player(0, 0); 

            generateLevel();
            updateTempSettingsDisplay();
            updateMegaSettingsDisplay(); // Call new display function
            
            requestAnimationFrame(gameLoop);
        }
        
        function updateTempSettingsDisplay() {
            TEMP_PROJ_DISPLAY.innerHTML = `
                Timed Laser: Speed: ${TEMP_PROJ_SPEED} | Radius: ${TEMP_PROJ_RADIUS} | Color: ${TEMP_PROJ_COLOR}<br>
                **Lifespan: ${TURRET_LIFESPAN_MS}ms** | **Refill Cooldown: ${TEMPORARY_TURRET_SPAWN_COOLDOWN_MS}ms** | **Max Active: ${MAX_ACTIVE_TEMPORARY_TURRETS}**
            `;
        }

        // --- NEW FUNCTION: Mega Settings Display ---
        function updateMegaSettingsDisplay() {
            MEGA_PROJ_DISPLAY.innerHTML = `
                MEGA Turret: Cooldown: ${MEGA_TURRET_COOLDOWN}ms | Big Proj Speed: ${MEGA_PROJECTILE_SPEED} | Big Proj Radius: ${MEGA_PROJECTILE_RADIUS}<br>
                **Explosion:** Count: ${MINI_PROJECTILE_COUNT} | Mini Proj Speed: ${MINI_PROJECTILE_SPEED} | Mini Proj Radius: ${MINI_PROJECTILE_RADIUS} | Color: ${MINI_PROJECTILE_COLOR}
            `;
        }
        // ------------------------------------------

        // --- Collision and Physics Logic ---

        function checkPlatformCollision() {
            platforms.forEach(p => {
                const pBounds = { left: p.x, right: p.x + p.width, top: p.y, bottom: p.y + p.height };
                const playerBounds = player.getBounds();

                if (
                    playerBounds.right > pBounds.left && playerBounds.left < pBounds.right &&
                    playerBounds.bottom > pBounds.top && playerBounds.top < pBounds.bottom
                ) {
                    const previousBottom = playerBounds.bottom - player.vy; 
                    const previousTop = playerBounds.top - player.vy;     
                    const y_axis_alignment = playerBounds.right > pBounds.left + 1 && playerBounds.left < pBounds.right - 1;
                    
                    let hitWallSide = 0; // 1 for moving into right wall, -1 for moving into left wall

                    // 1. VERTICAL COLLISION (Landing or Headbump)
                    if (player.vy >= 0 && previousBottom <= pBounds.top && y_axis_alignment) {
                        player.y = pBounds.top - player.height; 
                        player.vy = 0; 
                        player.onGround = true;
                        return; // Exit early as we've landed/hit ground
                    } 

                    else if (player.vy < 0 && previousTop >= pBounds.bottom && y_axis_alignment) {
                        player.y = pBounds.bottom;
                        player.vy = 0; 
                        return; // Exit early as we've hit our head
                    }

                    // 2. HORIZONTAL COLLISION (Wall Hit)
                    if (player.vx > 0 && playerBounds.right <= pBounds.left) {
                        player.x = pBounds.left - player.width;
                        hitWallSide = 1;
                    } 
                    else if (player.vx < 0 && playerBounds.left >= pBounds.right) {
                        player.x = pBounds.right;
                        hitWallSide = -1;
                    }

                    // 3. Wall Jump Logic Check
                    if (hitWallSide !== 0 && playerBounds.bottom > pBounds.top + 5 && playerBounds.top < pBounds.bottom - 5) {
                        player.onWall = true;
                        player.wallSide = hitWallSide;
                        // Slow vertical descent on wall contact
                        if (player.vy > 0) player.vy *= 0.2; 
                    }
                }
            });
        }

        // --- NEW PROJECTILE COLLISION LOGIC ---
        function checkProjectileCollision() {
            const newProjectiles = [];

            projectiles.forEach(proj => {
                let collision = false;
                
                // 1. Check Player Hit
                if (
                    proj.x + proj.radius > player.x && proj.x - proj.radius < player.x + player.width &&
                    proj.y + proj.radius > player.y && proj.y - proj.radius < player.y + player.height
                ) {
                    collision = true;
                    if (gameRunning) gameOver("You were hit by a projectile! Try again.");
                }

                // 2. Check Platform Hit (Triggers explosion for MegaProjectile)
                platforms.forEach(p => {
                    // Simple AABB check - approximate with a circle for simplicity
                    const closestX = Math.max(p.x, Math.min(proj.x, p.x + p.width));
                    const closestY = Math.max(p.y, Math.min(proj.y, p.y + p.height));
                    
                    const dx = proj.x - closestX;
                    const dy = proj.y - closestY;
                    
                    if ((dx * dx + dy * dy) < (proj.radius * proj.radius)) {
                        collision = true;
                        
                        // --- MEGA PROJECTILE EXPLOSION LOGIC ---
                        if (proj.isMega) {
                            // Add the newly created mini projectiles to the main list
                            newProjectiles.push(...proj.explodeIntoMiniProjectiles());
                            // Do NOT push the mega projectile back (it's dead/exploded)
                        }
                    }
                });

                // Add projectile back if it hasn't collided and is not dead (MegaProjectile only explodes, doesn't bounce/die otherwise)
                if (!collision && !proj.isDead) {
                    newProjectiles.push(proj);
                }
            });

            projectiles = newProjectiles;
        }


        function checkWinCondition() {
            if (collectible.collected) return; 

            const pBounds = player.getBounds();
            
            if (
                pBounds.right > collectible.x && pBounds.left < collectible.x + collectible.size &&
                pBounds.bottom > collectible.y && pBounds.top < collectible.y + collectible.size
            ) {
                collectible.collected = true;
                gameOver("Congratulations! You reached the gem!", true);
            }
        }

        function gameOver(message, win = false) {
            gameRunning = false;
            STATUS_MESSAGE.textContent = message;
            STATUS_MESSAGE.style.color = win ? '#00ffff' : '#ff4500';
            // Stop all projectiles for a clean game over screen
            projectiles = []; 
        }

        // --- Game Loop ---

        function draw() {
            ctx.clearRect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            ctx.fillStyle = '#2b3a55';
            ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

            ctx.shadowBlur = 0; 
            
            platforms.forEach(p => p.draw());
            
            turrets.forEach(t => t.draw());
            temporaryTurrets.forEach(t => t.draw());
            megaTurrets.forEach(t => t.draw()); // Draw mega turrets

            projectiles.forEach(p => p.draw());
            
            collectible.draw();
            player.draw();
        }

        function update(deltaTime) {
            if (!gameRunning) return;

            // 1. Player Update
            player.update(deltaTime);

            // 2. Refill Temporary Turrets
            temporaryTurretCooldown -= deltaTime;
            if (temporaryTurretCooldown <= 0) {
                attemptRefillTemporaryTurrets();
                temporaryTurretCooldown = TEMPORARY_TURRET_SPAWN_COOLDOWN_MS;
            }

            // 3. Update Turrets (Normal, Temporary, and Mega)
            turrets.forEach(t => t.update(deltaTime, projectiles));
            megaTurrets.forEach(t => t.update(deltaTime, projectiles));

            temporaryTurrets = temporaryTurrets.filter(t => {
                t.update(deltaTime, projectiles);
                return !t.isDead;
            });
            
            // 4. Update Projectiles
            projectiles.forEach(p => p.update());
            projectiles = projectiles.filter(p => !p.isDead);

            // 5. Collision Checks
            checkPlatformCollision();
            checkProjectileCollision(); // Updated to handle explosions
            checkWinCondition();
        }

        function gameLoop(currentTime) {
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;

            update(deltaTime);
            draw();

            requestAnimationFrame(gameLoop);
        }

        // --- Event Listeners ---

        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            if ((e.code === 'ArrowUp' || e.code === 'KeyW' || e.code === 'Space') && gameRunning) {
                e.preventDefault();
                player.jump();
            }
            if (e.code === 'KeyR') {
                e.preventDefault();
                initializeGame();
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.code] = false;
        });

        // Initialize the game when the page loads
        initializeGame();
    </script>
</body>
</html>  